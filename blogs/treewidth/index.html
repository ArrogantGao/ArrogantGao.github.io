<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/jemdoc.css"> <link rel=icon  href="/assets/profile.png"> <title>TreeWidthSolver.jl</title> <main class=outside > <div class=box > <aside class=layout-menu > <div class=menu-category >Xuanzhao Gao's Site</div> <div class="menu-item "><a href="/">Home</a></div> <div class=menu-category >Blogs</div> <div class="menu-item "><a href="/blogs/CuTropicalGEMM/">GEMM on GPU</a></div> <div class="menu-item "><a href="/blogs/treewidth">Optimizing Tensor Network Contraction Order</a></div> </aside> <div class=layout-content > <div class=franklin-content > <h1 id=tensor_network_contraction_order_optimization_with_tree_decomposition ><a href="#tensor_network_contraction_order_optimization_with_tree_decomposition" class=header-anchor >Tensor Network Contraction Order Optimization with Tree Decomposition</a></h1> <p>This blog is a technical note for the <a href="https://summerofcode.withgoogle.com">Google Summer of Code 2024</a> project <a href="https://summerofcode.withgoogle.com/programs/2024/projects/B8qSy9dO">&quot;Tensor network contraction order optimization and visualization&quot;</a> released by <strong>The Julia Language</strong>, where I developed a package <a href="https://github.com/ArrogantGao/TreeWidthSolver.jl">TreeWidthSolver.jl</a> for calculating the tree decomposition with minimal treewidth of a given simple graph and made it a backend of <a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContracionOrders.jl</a>.</p> <p>This blog covers the following contents:</p> <ol> <li><p>Contraction order of tensor network</p> <li><p>Tree decomposition and its relation to contraction order</p> <li><p>Finding tree decomposition with minimal treewidth</p> </ol> <h2 id=tensor_network_contraction_order ><a href="#tensor_network_contraction_order" class=header-anchor >Tensor Network Contraction Order</a></h2> <p>In this blog, we will not introduce the basic concept of tensor network, since it has been well introduced in many other places. Instead, we recommend the following references:</p> <ul> <li><p>For readers with physics background: <a href="https://tensornetwork.org/diagrams/">https://tensornetwork.org/diagrams/</a></p> <li><p>For readers want to get a formal definition: Chapter 2 of <a href="https://epubs.siam.org/doi/abs/10.1137/22M1501787">https://epubs.siam.org/doi/abs/10.1137/22M1501787</a></p> </ul> <p>For simplicity, in the following sections, we will use the Einstein summation formula to represent the tensor network as high dimensional arrays&#39; multiplication:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msub><mi>R</mi><mrow><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo separator=true >,</mo><mi>k</mi><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>a</mi><mo separator=true >,</mo><mi>b</mi><mo separator=true >,</mo><mi>c</mi><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow></munder><msub><mi>A</mi><mrow><mi>a</mi><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow></msub><msub><mi>B</mi><mrow><mi>b</mi><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow></msub><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">R_{i,j,k,...} = \sum_{a, b, c, ...} A_{a,...}B_{b,...}...</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.9694em;vertical-align:-0.2861em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:2.4882em;vertical-align:-1.4382em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class=pstrut  style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">c</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span></span></span></span><span style="top:-3.05em;"><span class=pstrut  style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.4382em;"><span></span></span></span></span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal">A</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mord >...</span></span></span></span></span> <p>It is easy to see that the most direct way to calculate the result is to loop over all the indices naively, which requires <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>d</mi><mi>N</mi></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(d^N)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">d</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> operations, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> is the dimension of the index and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is the number of indices. However, such a direct calculation is not efficient. Considering the following simple tensor network:</p> <p><img src="/assets/treewidth_figs/D10.png" alt="" /></p> <p>where the tensors are represented by the circles and the indices are represented by the lines, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator=true >,</mo><mi>B</mi><mo separator=true >,</mo><mi>C</mi><mo separator=true >,</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A, B, C, D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> are all rank-4 tensors, all indices are of dimension <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>. Naively loop over all the indices requires <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>12</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^{12})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> operations and producing no intermediate tensors. On the other hand, consider the following contraction order:</p> <p><img src="/assets/treewidth_figs/ABCD_contraction.png" alt="" /></p> <p>where we first contract <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> to get <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, then contract <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> to get <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">CD</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>, and finally contract <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">CD</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> to get the result. In this way, the total number of operations is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>10</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^{10})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, which is much smaller than the naive calculation, while the trade-off is that we need to store the intermediate tensors <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">CD</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> with size of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>8</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^{8})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>. We say such a contraction is with <strong>time complexity</strong> of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>10</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^{10})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> and <strong>space complexity</strong> of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>8</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^{8})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, which represents the number of operations and the largest size of the intermediate tensors, respectively.</p> <p>In actual calculation, we prefer such binary contractions, i.e., contracting two tensors at a time, and then contract the result with another tensor, and so on, so that we can make use of BLAS libraries to speed up the calculation. A given contraction order can be represented as a tree, and since we only apply binary contractions, the tree is a binary tree. The contraction tree can be represented as a rooted tree, where the leaves are the tensors to be contracted and the internal nodes are the intermediate tensors.</p> <h3 id=tools_for_tensor_network_contraction_order_optimization ><a href="#tools_for_tensor_network_contraction_order_optimization" class=header-anchor >Tools for Tensor Network Contraction Order Optimization</a></h3> <p>In practice, there are many tools for tensor network contraction order optimization, including:</p> <ul> <li><p><a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContractionOrder.jl</a>: an open-source Julia package for finding the optimal contraction order of tensor networks, is used as backend of <a href="https://github.com/under-Peter/OMEinsum.jl">OMEinsum.jl</a> and <a href="https://github.com/mtfishman/ITensorNetworks.jl">ITensorNetworks.jl</a>.</p> <li><p><a href="https://cotengra.readthedocs.io/en/latest/">Cotengra</a><sup id="fnref:Gray"><a href="#fndef:Gray" class=fnref >[1]</a></sup> : a python library for contracting tensor networks or einsum expressions involving large numbers of tensors.</p> </ul> <p>Various methods have been proposed for optimizing the contraction order, here we introduce some of them:</p> <h4 id=greedy_algorithm ><a href="#greedy_algorithm" class=header-anchor >Greedy Algorithm</a></h4> <p>The Greedy method is one of the simplest and fastest method for optimizing the contraction order. The idea is to greedily select the pair of tensors with the smallest cost to contract at each step. In each step, for all possible pairs of tensors, the cost of the contraction is evaluated, and the pair with the smallest cost is selected and then contracted, which forms a new tensor. This process is repeated until all tensors are contracted. This method is fast, however it is easy to be trapped in local minima.</p> <p>An enhanced method is called the hyper-greedy method, where in each step one does not directly select the pair with the smallest cost, but instead samples according to the Boltzmann distribution given by <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >P</mi><mo stretchy=false >(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator=true >,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=false >)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mrow><mi>L</mi><mo stretchy=false >(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator=true >,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=false >)</mo></mrow><mi mathvariant=normal >/</mi><mi>T</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathcal{P}(v_i, v_j) = e^{-{L(v_i, v_j)} / {T}}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.888em;"></span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator=true >,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(v_i, v_j)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> is the cost function. In this case, it is possible for the process to escape from local minima. Then we run this process multiple times and select the best result. The method has already been used in both OMEinsumContractionOrders.jl and Cotengra. </p> <h4 id=binary_partition ><a href="#binary_partition" class=header-anchor >Binary Partition</a></h4> <p>A given tensor network can be regarded as a hypergraph, where the tensors are the vertices and the shared indices are the hyperedges, and the cost of contracting a hyper edge can be encoded as its weight. The binary partition method is to partition the hypergraph into two parts, and then recursively partition each part. Cost of each partition can be evaluated by the sum of the weights of the hyperedges cut by the partition, while we prefer to make the partition as balanced as possible &#40;balance means size of the subgraph should be similar&#41;. Thus, the problem is reduced to a balanced min cut problem on a hypergraph. In the past few decades, the graph community has developed many algorithms for the balanced min cut problem and provided the corresponding software packages, such as <a href="https://kahypar.org">KaHyPar</a> <sup id="fnref:kahypar"><a href="#fndef:kahypar" class=fnref >[2]</a></sup>, which has already been used in both OMEinsumContractionOrders.jl and Cotengra. </p> <h4 id=tree_simulated_annealing ><a href="#tree_simulated_annealing" class=header-anchor >Tree Simulated Annealing</a></h4> <p>Tree simulating annealing &#40;TreeSA&#41; <sup id="fnref:Kalachev"><a href="#fndef:Kalachev" class=fnref >[3]</a></sup> is another type of the optimization method based on local search and simulating annealing. TreeSA is based on the following rules:</p> <ul> <li><p>Associativity: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>×</mo><mo stretchy=false >(</mo><mi>S</mi><mo>×</mo><mi>R</mi><mo stretchy=false >)</mo><mo>=</mo><mo stretchy=false >(</mo><mi>T</mi><mo>×</mo><mi>S</mi><mo stretchy=false >)</mo><mo>×</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">T \times (S \times R) = (T \times S) \times R</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</p> <li><p>Commutativity: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>×</mo><mi>S</mi><mo>=</mo><mi>S</mi><mo>×</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T \times S = S \times T</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</p> </ul> <p>These rules lead to the four possible transforms of the contraction tree as shown in the following figure.</p> <p><img src="/assets/treewidth_figs/treesa.png" alt="" /></p> <p>The TreeSA method starts from a random contraction tree and then applies the above rules to transform the tree. The cost of the contraction tree is evaluated and the tree is updated according to the Metropolis criterion. During the process, the temperature is gradually decreased, and the process stop when the temperature is low enough. The method has already been used in OMEinsumContractionOrders.jl.</p> <p>The method listed above are powerful and efficient, which can be used to find great contraction orders of the extremely large tensor networks. However, they are heuristic methods and may not guarantee to find the optimal contraction order. In the following sections, we will introduce a theoretical method to find the optimal contraction order based on the tree decomposition.</p> <h2 id=finding_the_optimal_contraction_order ><a href="#finding_the_optimal_contraction_order" class=header-anchor >Finding the Optimal Contraction Order</a></h2> <p>In the previous section, we introduce the concept of tensor network and its contraction order, so that now you should understand why the contraction order so important. Then the next question is how to find the optimal contraction order.</p> <p>In this section, we will introduce one way to find the theoretical optimal contraction order based on the exact tree width solver, according to the following well known theorem<sup id="fnref:Markov"><a href="#fndef:Markov" class=fnref >[4]</a></sup> :</p> <p><strong>Theorem 1</strong>. Let <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> be a quantum circuit with <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> gates and whose underlying circuit graph is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">G_c</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Then <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> can be simulated deterministically in time <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mrow><mi>O</mi><mo stretchy=false >(</mo><mn>1</mn><mo stretchy=false >)</mo></mrow></msup><msup><mi>e</mi><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><msub><mi>G</mi><mi>C</mi></msub><mo stretchy=false >)</mo><mo stretchy=false >)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">T^{O(1)} e^{O(tw(G_C))}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.888em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">tw</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3448em;"><span style="top:-2.3567em;margin-left:0em;margin-right:0.0714em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.1433em;"><span></span></span></span></span></span></span><span class="mclose mtight">))</span></span></span></span></span></span></span></span></span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><msub><mi>G</mi><mi>C</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">tw(G_C)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">tw</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> is the treewidth of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">G_C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p> <p>Using the language of tensor network, we can rewrite the above theorem as follows: the bottleneck of time complexity of the contraction of a tensor network is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>e</mi><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo><mo stretchy=false >)</mo><mo stretchy=false >)</mo></mrow></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(e^{O(tw(L(G)))})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">tw</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">G</span><span class="mclose mtight">)))</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> is the line graph of the hypergraph of the tensor network. Therefore, if we can find the tree decomposition of the tensor network with minimal treewidth, we can find the optimal contraction order of the tensor network.</p> <p>To further make use of the theorem, we need to introduce the concepts of line graph, tree width and tree decomposition.</p> <h3 id=line_graph ><a href="#line_graph" class=header-anchor >Line Graph</a></h3> <p>A formal definition of the <a href="https://en.wikipedia.org/wiki/Line_graph"><strong>line graph</strong></a> is as follows:</p> <p><strong>Definition 1</strong>. Given a graph G, its line graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> is a graph such that: </p> <ol> <li><p>each vertex of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> represents an edge of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>; </p> <li><p>two vertices of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> are adjacent if and only if their corresponding edges share a common endpoint &#40;&quot;are incident&quot;&#41; in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>. </p> </ol> <p>That is, it is the intersection graph of the edges of G, representing each edge by the set of its two endpoints.</p> <p>For a tensor network, we can construct a hypergraph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> whose vertices are the tensors and whose hyperedges are the indices. Then the line graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> of the hypergraph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is the graph whose vertices are the indices and whose edges are the tensors, which is a simple graph, as shown in the following figure:</p> <p><img src="/assets/treewidth_figs/linegraph.png" alt=Fig.1  /></p> <p>Since we are considering a tensor network, dimension of the indices have to be considered. Therefore, for each vertex of the line graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>, we define its weight as <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy=false >(</mo><mi>d</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\log_2(d)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop ><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2441em;"><span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">d</span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> is the dimension of the index. </p> <p>In this way, any possible tensor can be represented as a subgraph induced by a set of vertices in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>, and its log2 size is given by the sum of weights of the boundary vertices of the subgraph. For example, the tensor <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> in the figure above corresponding to the subgraph induced by the vertices <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >{</mo><mi>b</mi><mo separator=true >,</mo><mi>d</mi><mo separator=true >,</mo><mi>f</mi><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\{b, d, f\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal">b</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mclose >}</span></span></span></span>, and its log2 size is </p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mrow><mi>d</mi><mi>i</mi><mi>m</mi><mi>s</mi><mo stretchy=false >(</mo><mi>b</mi><mo stretchy=false >)</mo><mo>×</mo><mi>d</mi><mi>i</mi><mi>m</mi><mi>s</mi><mo stretchy=false >(</mo><mi>d</mi><mo stretchy=false >)</mo><mo>×</mo><mi>d</mi><mi>i</mi><mi>m</mi><mi>s</mi><mo stretchy=false >(</mo><mi>f</mi><mo stretchy=false >)</mo></mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>w</mi><mo stretchy=false >(</mo><mi>b</mi><mo stretchy=false >)</mo><mo>+</mo><mi>w</mi><mo stretchy=false >(</mo><mi>d</mi><mo stretchy=false >)</mo><mo>+</mo><mi>w</mi><mo stretchy=false >(</mo><mi>f</mi><mo stretchy=false >)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">{dims(b) \times dims(d) \times dims(f)} = 2^{w(b) + w(d) + w(f)}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">d</span><span class="mord mathnormal">im</span><span class="mord mathnormal">s</span><span class=mopen >(</span><span class="mord mathnormal">b</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">im</span><span class="mord mathnormal">s</span><span class=mopen >(</span><span class="mord mathnormal">d</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">im</span><span class="mord mathnormal">s</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mclose >)</span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.938em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">d</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span> <p>where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy=false >(</mo><mo>∗</mo><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">w(*)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class=mopen >(</span><span class=mord >∗</span><span class=mclose >)</span></span></span></span> for weights of vertices.</p> <h3 id=tree_decomposition_and_tree_width ><a href="#tree_decomposition_and_tree_width" class=header-anchor >Tree Decomposition and Tree Width</a></h3> <p>Intuitively, a <a href="https://en.wikipedia.org/wiki/Tree_decomposition"><strong>tree decomposition</strong></a> represents the vertices of a given graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> as subtrees of a tree, in such a way that vertices in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> are adjacent only when the corresponding subtrees intersect.</p> <p>The tree decomposition of a graph is a tree whose nodes are subsets of the vertices of the graph, and the following conditions are satisfied:</p> <ol> <li><p>Each vertex of the graph is in at least one node of the tree.</p> <li><p>For each edge of the graph, there is a node of the tree containing both vertices of the edge.</p> <li><p>Bags containing the same vertex have to be connected in the tree.</p> </ol> <p>An example of tree decomposition is shown in the following figure:</p> <p><img src="/assets/treewidth_figs/treedecomposition.png" alt="" /></p> <p>where the left graph is the original graph and the right one is the tree decomposition of the graph.</p> <p>All the nodes of the tree are called <strong>tree bags</strong>, and the intersection of two bags is called a <strong>separator</strong>. The width of a tree decomposition is the size of the largest bag minus one, thus the width of the example above is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >2</span></span></span></span>. Clearly, one graph can have multiple tree decompositions, and the <strong>tree width</strong> of a graph is the minimum width of all possible tree decompositions. For graphs with weights on vertices, we define the width as sum of weights of the vertices in the bags minus one.</p> <h3 id=from_tree_decomposition_to_contraction_order ><a href="#from_tree_decomposition_to_contraction_order" class=header-anchor >From Tree Decomposition to Contraction Order</a></h3> <p>Then how tree decomposition and tree width are related to the contraction order of the tensor network? In this sub-section, we will answer the following questions: how to get a contraction order from a tree decomposition? And why the contraction order is optimal if the tree width is minimal?</p> <p>For the first question, according to the definition of tree decomposition, we can obtain vertices elimination order by traversing the tree decomposition in a bottom-up manner. For each node of the tree decomposition, a vertex can be eliminated if it is in the bag of the node and not in the bags of its parent node. The elimination order can then be used to determine the contraction order of the tensor network, where two tensors are contracted if they share a common index and the index is eliminated. An example of contraction order is shown in the following figure:</p> <p><img src="/assets/treewidth_figs/elimination.png" alt="" /></p> <p>where the tree decomposition gives the elimination order <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator=true >,</mo><mi>b</mi><mo separator=true >,</mo><mi>d</mi><mo separator=true >,</mo><mi>f</mi><mo separator=true >,</mo><mi>c</mi><mo separator=true >,</mo><mi>h</mi><mo separator=true >,</mo><mi>e</mi><mo separator=true >,</mo><mi>g</mi><mo separator=true >,</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">a, b, d, f, c, h, e, g, i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span></span></span></span>, and this lead to a contraction order <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mo stretchy=false >(</mo><mo stretchy=false >(</mo><mo stretchy=false >(</mo><mo stretchy=false >(</mo><mi>A</mi><mo separator=true >,</mo><mi>B</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>C</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>F</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>D</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>E</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(((((A, B), C), F), D), E)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(((((</span><span class="mord mathnormal">A</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class=mclose >)</span></span></span></span>. Of course, the contraction order is not unique by selecting different node as the root of the decomposition tree, but the space complexity of the contraction is the same for all possible contraction orders.</p> <p>For the second question, we have the following two reasons:</p> <ol> <li><p>Width of the tree decomposition is an upper bound of the space complexity of the corresponding contraction.</p> <li><p>Total dimension of the indices in the same tree bag is the time complexity of the corresponding step of the contraction.</p> </ol> <p>For example, in the first step of the construction above, the index <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is eliminated, and the corresponding operations is</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msubsup><mi>A</mi><mrow><mi>b</mi><mi>c</mi><mi>d</mi><mi>e</mi></mrow><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msubsup><mo>=</mo><munder><mo>∑</mo><mi>a</mi></munder><msub><mi>A</mi><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow></msub><msub><mi>B</mi><mrow><mi>c</mi><mi>d</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A&#x27;_{bcde} = \sum_{a} A_{abc} B_{cde}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0489em;vertical-align:-0.247em;"></span><span class=mord ><span class="mord mathnormal">A</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8019em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.247em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:2.3em;vertical-align:-1.25em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class=pstrut  style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.05em;"><span class=pstrut  style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.25em;"><span></span></span></span></span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal">A</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ab</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> <p>where the space complexity is bounded by width and the time complexity is given by the dimension of the indices in bag.</p> <p>Thus, finding the tree decomposition with minimal width is equivalent to finding the optimal contraction order of the tensor network, with a bounded space complexity and minimal time complexity.</p> <h2 id="the_bouchittétodinca_algorithm_for_tree_width"><a href="#the_bouchittétodinca_algorithm_for_tree_width" class=header-anchor >The Bouchitté–Todinca Algorithm for Tree Width</a></h2> <p>In the previous sections, we introduced the connection between tree decomposition and contraction order, and the importance of finding the tree decomposition with minimal width. Thus, next question is: <strong>How to find the tree decomposition with minimal width?</strong></p> <p>In previous few decades, methods have been proposed to find the tree decomposition with minimal width, including exact algorithms and heuristic algorithms. In this section, we will introduce the Bouchitté–Todinca &#40;BT&#41; algorithm<sup id="fnref:Bouchitté"><a href="#fndef:Bouchitté" class=fnref >[5]</a></sup> for finding the tree decomposition with minimal width.</p> <p>Generally speaking, the BT algorithm is a dynamic programming algorithm. Given a set of possible tree bags, the algorithm can search a set of tree bags forming a tree decomposition with minimal width. It has been proved that for a decomposition with minimal width, all bags are <strong>potential maximal cliques</strong> &#40;pmc&#41;. Thus the BT algorithm contains two phases, it first search for all pmcs, and then search the minimal width decomposition with the pmcs.</p> <h3 id=minimum_separator_and_potential_maximal_cliques ><a href="#minimum_separator_and_potential_maximal_cliques" class=header-anchor >Minimum Separator and Potential Maximal Cliques</a></h3> <p>To introduce the algorithm, we first need to introduce the concept of <strong>minimum separator</strong><sup id="fnref:Berry"><a href="#fndef:Berry" class=fnref >[6]</a></sup> and <strong>potential maximal cliques</strong><sup id="fnref:BouchittéListing"><a href="#fndef:BouchittéListing" class=fnref >[7]</a></sup>, which are the intersection of two bags and possible tree bags, respectively.</p> <p><strong>Definition 2</strong>. A subset <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">S \subseteq V</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >⊆</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> is an <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator=true >,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span></span></span></span>-separator for two nonadjacent vertices <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator=true >,</mo><mi>b</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">a, b \in V</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> if the removal of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> from the graph separates <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> in different connected components. <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is a minimal <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator=true >,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span></span></span></span>-separator if no proper subset of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> separates <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>.</p> <p>For all pairs of nonadjacent vertices <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator=true >,</mo><mi>b</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">a, b \in V</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, the set of all minimal <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator=true >,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span></span></span></span>-separators are called the minimal separators of the graph, represented by <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\Delta(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >Δ</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>. In practice, we can examine a set of vertices <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> by checking properties of the connected components of the graph after removing <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, represented as <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >C</mi><mo stretchy=false >(</mo><mi>G</mi><mi mathvariant=normal >/</mi><mi>S</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\mathcal{C}(G / S)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mord >/</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mclose >)</span></span></span></span>:</p> <ul> <li><p>If there are two or more connected components <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>∈</mo><mi mathvariant=script >C</mi><mo stretchy=false >(</mo><mi>G</mi><mi mathvariant=normal >/</mi><mi>S</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">C \in \mathcal{C}(G / S)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mord >/</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mclose >)</span></span></span></span> whose neighbor is exactly the set <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, then <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is a separator, and the components are called <strong>full components</strong>.</p> </ul> <p><strong>Definition 3</strong>. A vertex set <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span></span></span></span> of a graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is called a potential maximal clique if there is a minimal triangulation <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> such that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span></span></span></span> is a maximal clique of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>.</p> <p>Minimal triangulation is a graph obtained by adding edges to the graph such that the resulting graph is chordal. The set of all possible pmcs of a graph is represented by <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Π</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\Pi(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >Π</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>. In practice, we can use the following conditions to check whether a set of vertices <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span></span></span></span> is a pmc:</p> <ul> <li><p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span></span></span></span> has no full component.</p> <li><p>For any pair of distinct vertices <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator=true >,</mo><mi>v</mi><mo>∈</mo><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">u, v \in Ω</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span></span></span></span>, either <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>u</mi><mo separator=true >,</mo><mi>v</mi><mo stretchy=false >)</mo><mo>∈</mo><mi>E</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(u, v) \in E(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">u</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> or there is a component <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>∈</mo><mi mathvariant=script >C</mi><mo stretchy=false >(</mo><mi>G</mi><mi mathvariant=normal >/</mi><mi mathvariant=normal >Ω</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">C \in \mathcal{C}(G / \Omega)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mord >/Ω</span><span class=mclose >)</span></span></span></span> with <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>u</mi><mo separator=true >,</mo><mi>v</mi><mo stretchy=false >)</mo><mo>∈</mo><mi>N</mi><mo stretchy=false >(</mo><mi>C</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(u, v) \in N(C)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">u</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mclose >)</span></span></span></span>.</p> </ul> <p>In the first phase, the BT algorithm enumerate the set of all pmcs, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Π</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\Pi(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >Π</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>.</p> <h4 id=enumerating_minimal_separators ><a href="#enumerating_minimal_separators" class=header-anchor >Enumerating Minimal Separators</a></h4> <p>We first introduce the method introduced by Berry<sup id="fnref:Berry"><a href="#fndef:Berry" class=fnref >[6]</a></sup> to enumerate all minimal separators of a graph, which is part of the method to search for all pmcs. Briefly, the algorithm makes use of the fact that given a separator, neighbors of its components are minimal separators. Then the algorithm starts from the simplest minimal separator, i.e., neighbors of a single vertex, and then iteratively add vertices to the separator to find all minimal separators. The algorithm is shown below:</p> <p><img src="/assets/treewidth_figs/min_seps.png" alt="alt text" /></p> <p>An example to enumerate all minimal separators is shown below:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> TreeWidthSolver, Graphs

julia&gt; g = smallgraph(:cubical)
{<span class=hljs-number >8</span>, <span class=hljs-number >12</span>} undirected simple <span class=hljs-built_in >Int64</span> graph

<span class=hljs-comment ># covert the graph to a labeled simple graph, which is a structure of graph defined in TreeWidthSolver.jl</span>
julia&gt; all_min_sep(LabeledSimpleGraph(g))
<span class=hljs-built_in >Set</span>{<span class=hljs-built_in >Set</span>{<span class=hljs-built_in >Int64</span>}} with <span class=hljs-number >14</span> elements:
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >4</span>, <span class=hljs-number >7</span>, <span class=hljs-number >8</span>, <span class=hljs-number >1</span>])
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >4</span>, <span class=hljs-number >7</span>, <span class=hljs-number >2</span>])
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >5</span>, <span class=hljs-number >7</span>, <span class=hljs-number >2</span>])
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >4</span>, <span class=hljs-number >6</span>, <span class=hljs-number >2</span>, <span class=hljs-number >8</span>])
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >5</span>, <span class=hljs-number >7</span>, <span class=hljs-number >3</span>, <span class=hljs-number >1</span>])
  ...</code></pre> <h4 id=enumerating_potential_maximal_cliques ><a href="#enumerating_potential_maximal_cliques" class=header-anchor >Enumerating Potential Maximal Cliques</a></h4> <p>Then we introduce the method to enumerate all pmcs of a graph<sup id="fnref:BouchittéListing"><a href="#fndef:BouchittéListing" class=fnref >[7]</a></sup>, where the set of pmcs is constructed iteratively.</p> <p>The algorithm first constructs a set of induced subgraphs <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator=true >,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mo separator=true >,</mo><msub><mi>G</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">G_1, G_2, ..., G_N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8778em;vertical-align:-0.1944em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >...</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, starting from only one vertex and then iteratively add vertices to the subgraphs. For the <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>-th subgraph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, the algorithm first find all minimal separators <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Δ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Delta_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of the graph, and then use <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Δ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Delta_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Π</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{i - 1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8917em;vertical-align:-0.2083em;"></span><span class=mord ><span class=mord >Π</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> to find <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Π</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Pi_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Π</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Π</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{i - 1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8917em;vertical-align:-0.2083em;"></span><span class=mord ><span class=mord >Π</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> is the set of pmcs of the previous subgraph, since all pmcs of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">G_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> satisfies one of these conditions:</p> <ul> <li><p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi><mo>=</mo><msup><mi mathvariant=normal >Ω</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo>∪</mo><mo stretchy=false >{</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\Omega = \Omega&#x27; \cup \{v_i\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.7519em;"></span><span class=mord ><span class=mord >Ω</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >}</span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant=normal >Ω</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo>∈</mo><msub><mi mathvariant=normal >Π</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\Omega&#x27; \in \Pi_{i - 1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.791em;vertical-align:-0.0391em;"></span><span class=mord ><span class=mord >Ω</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8917em;vertical-align:-0.2083em;"></span><span class=mord ><span class=mord >Π</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo>=</mo><mi>V</mi><mo stretchy=false >(</mo><msub><mi>G</mi><mi>i</mi></msub><mo stretchy=false >)</mo><mo>∖</mo><mi>V</mi><mo stretchy=false >(</mo><msub><mi>G</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">v_i = V(G_i) \setminus V(G_{i - 1})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5806em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∖</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2083em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span></p> <li><p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi><mo>=</mo><msup><mi mathvariant=normal >Ω</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup></mrow><annotation encoding="application/x-tex">\Omega = \Omega&#x27;</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.7519em;"></span><span class=mord ><span class=mord >Ω</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant=normal >Ω</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo>∈</mo><msub><mi mathvariant=normal >Π</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\Omega&#x27; \in \Pi_{i - 1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.791em;vertical-align:-0.0391em;"></span><span class=mord ><span class=mord >Ω</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8917em;vertical-align:-0.2083em;"></span><span class=mord ><span class=mord >Π</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></p> <li><p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi><mo>=</mo><mi>S</mi><mo>∪</mo><mo stretchy=false >{</mo><mi>a</mi><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\Omega = S \cup \{a\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal">a</span><span class=mclose >}</span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><msub><mi mathvariant=normal >Δ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S \in \Delta_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p> <li><p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi><mo>=</mo><msub><mi>S</mi><mn>1</mn></msub><mo>∪</mo><mo stretchy=false >(</mo><mi>C</mi><mo>∩</mo><msub><mi>S</mi><mn>2</mn></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\Omega = S_1 \cup (C \cap S_2)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∩</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mo>∗</mo></msub><mo>∈</mo><msub><mi mathvariant=normal >Δ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_* \in \Delta_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.1757em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>∈</mo><mi mathvariant=script >C</mi><mo stretchy=false >(</mo><msub><mi>G</mi><mi>i</mi></msub><mo>∖</mo><mi>S</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">C \in \mathcal{C}(G_i \setminus S)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∖</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mclose >)</span></span></span></span></p> </ul> <p>The algorithm is shown below: <img src="/assets/treewidth_figs/pmcs.png" alt="alt text" /></p> <p><img src="/assets/treewidth_figs/one_more_vertex.png" alt="alt text" /></p> <p>Here is an example to enumerate all pmcs of a graph:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> TreeWidthSolver, Graphs

julia&gt; g = smallgraph(:cubical)
{<span class=hljs-number >8</span>, <span class=hljs-number >12</span>} undirected simple <span class=hljs-built_in >Int64</span> graph

julia&gt; all_pmc(LabeledSimpleGraph(g))
<span class=hljs-built_in >Set</span>{<span class=hljs-built_in >Set</span>{<span class=hljs-built_in >Int64</span>}} with <span class=hljs-number >34</span> elements:
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >5</span>, <span class=hljs-number >4</span>, <span class=hljs-number >8</span>, <span class=hljs-number >3</span>, <span class=hljs-number >1</span>])
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >4</span>, <span class=hljs-number >6</span>, <span class=hljs-number >7</span>, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>])
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >5</span>, <span class=hljs-number >4</span>, <span class=hljs-number >2</span>, <span class=hljs-number >8</span>, <span class=hljs-number >3</span>])
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >5</span>, <span class=hljs-number >6</span>, <span class=hljs-number >7</span>, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>])
  <span class=hljs-built_in >Set</span>([<span class=hljs-number >4</span>, <span class=hljs-number >6</span>, <span class=hljs-number >3</span>, <span class=hljs-number >1</span>])
  ...</code></pre> <h3 id=constructing_the_tree_decomposition ><a href="#constructing_the_tree_decomposition" class=header-anchor >Constructing the Tree Decomposition</a></h3> <p>In the second phase, with all pmcs, the algorithm constructs the tree decomposition with minimal width. First, we use the pmcs to construct all possible <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi mathvariant=normal >Ω</mi><mo separator=true >,</mo><mi>S</mi><mo separator=true >,</mo><mi>C</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(\Omega, S, C)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >Ω</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mclose >)</span></span></span></span> in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊊</mo><mi mathvariant=normal >Ω</mi><mo>⊆</mo><mo stretchy=false >(</mo><mi>S</mi><mo>∪</mo><mi>C</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">S \subsetneq \Omega \subseteq (S \cup C)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊊</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8193em;vertical-align:-0.136em;"></span><span class=mord >Ω</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >⊆</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mclose >)</span></span></span></span>. For example, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msub><mi mathvariant=normal >Ω</mi><mn>1</mn></msub><mo separator=true >,</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator=true >,</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(\Omega_1, S_1, C_1)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class=mord >Ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> in the following graph is a possible triple. Then we can sort all these triples according to the size of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∪</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S \cup C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, and the largest ones are simply <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi mathvariant=normal >Ω</mi><mo separator=true >,</mo><mi mathvariant=normal >∅</mi><mo separator=true >,</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(\Omega, \emptyset, G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >Ω</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >∅</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi><mo>∈</mo><mi mathvariant=normal >Π</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\Omega \in \Pi(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7224em;vertical-align:-0.0391em;"></span><span class=mord >Ω</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >Π</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>.</p> <p><img src="/assets/treewidth_figs/SC_pairs.png" alt="alt text" /></p> <p>It has been proved that the following property holds: for each pairs of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>S</mi><mo separator=true >,</mo><mi>C</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(S, C)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mclose >)</span></span></span></span>, its width is given by the size of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span></span></span></span> minus one or the largest width of all pair of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msup><mi>S</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo separator=true >,</mo><msup><mi>C</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(S&#x27;, C&#x27;)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0019em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> as its subset. For example, width of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator=true >,</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(S_1, C_1)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> written as <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy=false >(</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator=true >,</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">w(S_1, C_1)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> is given by</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>w</mi><mo stretchy=false >(</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator=true >,</mo><msub><mi>C</mi><mn>1</mn></msub><mo stretchy=false >)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi mathvariant=normal >∣</mi><msub><mi mathvariant=normal >Ω</mi><mn>1</mn></msub><mi mathvariant=normal >∣</mi><mo>−</mo><mn>1</mn><mo separator=true >,</mo><mi>w</mi><mo stretchy=false >(</mo><msub><mi>S</mi><mn>2</mn></msub><mo separator=true >,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy=false >)</mo><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">w(S_1, C_1) = \max(|\Omega_1| - 1, w(S_2, C_2))</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop >max</span><span class=mopen >(</span><span class=mord >∣</span><span class=mord ><span class=mord >Ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord >∣</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >))</span></span></span></span></span> <p>while</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>w</mi><mo stretchy=false >(</mo><msub><mi>S</mi><mn>2</mn></msub><mo separator=true >,</mo><msub><mi>C</mi><mn>2</mn></msub><mo stretchy=false >)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi mathvariant=normal >∣</mi><msub><mi mathvariant=normal >Ω</mi><mn>2</mn></msub><mi mathvariant=normal >∣</mi><mo>−</mo><mn>1</mn><mo separator=true >,</mo><mi>w</mi><mo stretchy=false >(</mo><msub><mi>S</mi><mn>3</mn></msub><mo separator=true >,</mo><msub><mi>C</mi><mn>3</mn></msub><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>w</mi><mo stretchy=false >(</mo><msub><mi>S</mi><mn>4</mn></msub><mo separator=true >,</mo><msub><mi>C</mi><mn>4</mn></msub><mo stretchy=false >)</mo><mo stretchy=false >)</mo><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">w(S_2, C_2) = \max(|\Omega_2| - 1, w(S_3, C_3), w(S_4, C_4)).</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop >max</span><span class=mopen >(</span><span class=mord >∣</span><span class=mord ><span class=mord >Ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord >∣</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >))</span><span class=mord >.</span></span></span></span></span> <p>If the pair <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>S</mi><mo separator=true >,</mo><mi>C</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(S, C)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mclose >)</span></span></span></span> has no subset, then its width is given by the size of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class=mord >Ω</span></span></span></span> minus one, corresponding to the leaf of the tree decomposition. In the end, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo><mo>=</mo><mi>w</mi><mo stretchy=false >(</mo><mi mathvariant=normal >∅</mi><mo separator=true >,</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">tw(G) = w(\emptyset, G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">tw</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class=mopen >(</span><span class=mord >∅</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>.</p> <p>This leads to a dynamic programming algorithm to find minimal width, where we can calculate the width of the leaves first, and then we will be able to iteratively calculate the width of the larger pairs. The algorithm<sup id="fnref:Tuukka"><a href="#fndef:Tuukka" class=fnref >[8]</a></sup> is shown below, we used the version rewritten by Tuukka Korhonen, which is clearer and more readable.</p> <p><img src="/assets/treewidth_figs/btdp.png" alt="alt text" /></p> <p>The algorithm gives both minimal width and also the corresponding tree decomposition, which can be used to find the optimal contraction order of the tensor network. For details about the implementation of the BT algorithm, please refer to the <a href="https://github.com/ArrogantGao/TreeWidthSolver.jl">TreeWidthSolver.jl</a> package.</p> <p>Here is an example:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> TreeWidthSolver, Graphs

julia&gt; g = smallgraph(:cubical)
{<span class=hljs-number >8</span>, <span class=hljs-number >12</span>} undirected simple <span class=hljs-built_in >Int64</span> graph

julia&gt; exact_treewidth(LabeledSimpleGraph(g))
tree width: <span class=hljs-number >3</span>
tree decomposition:
<span class=hljs-built_in >Set</span>([<span class=hljs-number >4</span>, <span class=hljs-number >6</span>, <span class=hljs-number >3</span>, <span class=hljs-number >1</span>])
└─ <span class=hljs-built_in >Set</span>([<span class=hljs-number >6</span>, <span class=hljs-number >8</span>, <span class=hljs-number >3</span>, <span class=hljs-number >1</span>])
   ├─ <span class=hljs-built_in >Set</span>([<span class=hljs-number >5</span>, <span class=hljs-number >6</span>, <span class=hljs-number >8</span>, <span class=hljs-number >1</span>])
   ├─ <span class=hljs-built_in >Set</span>([<span class=hljs-number >6</span>, <span class=hljs-number >7</span>, <span class=hljs-number >8</span>, <span class=hljs-number >3</span>])
   └─ <span class=hljs-built_in >Set</span>([<span class=hljs-number >2</span>, <span class=hljs-number >8</span>, <span class=hljs-number >3</span>, <span class=hljs-number >1</span>])</code></pre> <p>where both tree width and the corresponding tree decomposition are given.</p> <h3 id=tensor_network_with_open_edges ><a href="#tensor_network_with_open_edges" class=header-anchor >Tensor Network with Open Edges</a></h3> <p>In the previous sections, we introduced how to construct an optimal contraction order for a tensor network with no open edges by finding the optimal tree decomposition of its line graph, where all indices are contracted. However, in practice, we often encounter tensor networks with open edges, where some indices are not contracted. In this case, method based on bi-partition or tree decomposition can not be directly applied, since the complexity contributed by the open edges will not be reduced by any contraction, and neither balance min cut nor tree decomposition can correctly handle that.</p> <p>To solve this problem, we develop a method by add a dummy tensor to the tensor network, where the dummy tensor has the same dimension as the open indices, and the dummy tensor is connected to all the tensors with open indices. Then we can obtain the contraction order of the new network, which can be easy since now there is no open edges. Finally, the contraction tree is rotated without changing the contraction complexity, which makes the dummy tensor the last tensor to be contracted so that can be removed, and the contraction order of the original tensor network is obtained.</p> <p>For example, consider the following contraction:</p> <p><img src="/assets/treewidth_figs/dummy.png" alt="alt text" /></p> <p>where the leaf one is the original tensor network with three open edges, and a dummy tensor <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> is added as shown in the right figure. Then we may get a contraction order shown below, where the dummy tensor can be anywhere in the contraction tree, and the red line represents the path to it. Along the path to the dummy tensor, we rotate the nodes locally. For example, from the left one to the middle one, we consider the contraction <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo separator=true >,</mo><mi>i</mi><mi>j</mi><mi>m</mi><mi>n</mi><mo>→</mo><mi>j</mi><mi>k</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">B, ijmn \to jkm</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">ijmn</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >→</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">jkm</span></span></span></span>, and we rotate the <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>j</mi><mi>m</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">ijmn</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ijmn</span></span></span></span>, which is an intermediate tensor on the path, as root and make <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mi>k</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">jkm</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">jkm</span></span></span></span> &#40;<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>&#41; its children. Similarly, in next step we rotate the contraction <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator=true >,</mo><mi>D</mi><mo>→</mo><mi>i</mi><mi>k</mi><mi>m</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">A, D \to ikmn</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >→</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">ikmn</span></span></span></span>, and make <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> the last tensor to be contracted, so that by removing <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> we get the contraction order of the original tensor network.</p> <p><img src="/assets/treewidth_figs/pivot_tree.png" alt="alt text" /></p> <p>It should be noted that in such process we only rotate the nodes locally without inducing any additional intermediate tensors, thus the complexity of the contraction is not changed. This strategy can change the construction order optimization problem of tensor network with open edges to that of network without open edges, so that various graph based methods can be applied.</p> <p>The method have been implemented in the <a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContractionOrders.jl</a>, please see the function <code>pivot_tree</code> for detailed implementation. Here is an simple example:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> OMEinsumContractionOrders

<span class=hljs-comment ># the original tensor network</span>
julia&gt; eincode_origin = OMEinsumContractionOrders.EinCode([[<span class=hljs-string >&#x27;a&#x27;</span>, <span class=hljs-string >&#x27;b&#x27;</span>], [<span class=hljs-string >&#x27;a&#x27;</span>, <span class=hljs-string >&#x27;c&#x27;</span>, <span class=hljs-string >&#x27;d&#x27;</span>], [<span class=hljs-string >&#x27;b&#x27;</span>, <span class=hljs-string >&#x27;c&#x27;</span>, <span class=hljs-string >&#x27;e&#x27;</span>, <span class=hljs-string >&#x27;f&#x27;</span>], [<span class=hljs-string >&#x27;e&#x27;</span>]], [<span class=hljs-string >&#x27;d&#x27;</span>, <span class=hljs-string >&#x27;f&#x27;</span>])
ab, acd, bcef, e -&gt; df

<span class=hljs-comment ># with dummy tensor</span>
julia&gt; eincode = OMEinsumContractionOrders.EinCode([[<span class=hljs-string >&#x27;a&#x27;</span>, <span class=hljs-string >&#x27;b&#x27;</span>], [<span class=hljs-string >&#x27;a&#x27;</span>, <span class=hljs-string >&#x27;c&#x27;</span>, <span class=hljs-string >&#x27;d&#x27;</span>], [<span class=hljs-string >&#x27;b&#x27;</span>, <span class=hljs-string >&#x27;c&#x27;</span>, <span class=hljs-string >&#x27;e&#x27;</span>, <span class=hljs-string >&#x27;f&#x27;</span>], [<span class=hljs-string >&#x27;e&#x27;</span>], [<span class=hljs-string >&#x27;d&#x27;</span>, <span class=hljs-string >&#x27;f&#x27;</span>]], <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Char</span>}())
ab, acd, bcef, e, df -&gt;

julia&gt; nested_code = optimize_code(eincode, uniformsize(eincode, <span class=hljs-number >2</span>), ExactTreewidth())
ab, ab -&gt;
├─ ab
└─ acf, bcf -&gt; ab
   ├─ acd, df -&gt; acf
   │  ├─ acd
   │  └─ df
   └─ bcef, e -&gt; bcf
      ├─ bcef
      └─ e

<span class=hljs-comment ># remove the dummy tensor</span>
julia&gt; OMEinsumContractionOrders.pivot_tree(nested_code, <span class=hljs-number >5</span>)
acf, acd -&gt; df
├─ ab, bcf -&gt; acf
│  ├─ ab
│  └─ bcef, e -&gt; bcf
│     ├─ bcef
│     └─ e
└─ acd

<span class=hljs-comment ># it can also be used directly, the process above will be done automatically</span>
julia&gt; nested_code_direct = optimize_code(eincode_origin, uniformsize(eincode, <span class=hljs-number >2</span>), ExactTreewidth())
acf, acd -&gt; df
├─ ab, bcf -&gt; acf
│  ├─ ab
│  └─ bcef, e -&gt; bcf
│     ├─ bcef
│     └─ e
└─ acd</code></pre> <h2 id=reference ><a href="#reference" class=header-anchor >Reference</a></h2> <p><table class=fndef  id="fndef:Gray"> <tr> <td class=fndef-backref ><a href="#fnref:Gray">[1]</a> <td class=fndef-content >Gray, Johnnie, and Stefanos Kourtis. “Hyper-Optimized Tensor Network Contraction.” Quantum 5 &#40;March 15, 2021&#41;: 410. <a href="https://doi.org/10.22331/q-2021-03-15-410">https://doi.org/10.22331/q-2021-03-15-410</a>. </table> <table class=fndef  id="fndef:kahypar"> <tr> <td class=fndef-backref ><a href="#fnref:kahypar">[2]</a> <td class=fndef-content >Schlag, Sebastian, Tobias Heuer, Lars Gottesbüren, Yaroslav Akhremtsev, Christian Schulz, and Peter Sanders. “High-Quality Hypergraph Partitioning.” ACM Journal of Experimental Algorithmics 27 &#40;December 31, 2022&#41;: 1–39. <a href="https://doi.org/10.1145/3529090">https://doi.org/10.1145/3529090</a>. </table> <table class=fndef  id="fndef:Kalachev"> <tr> <td class=fndef-backref ><a href="#fnref:Kalachev">[3]</a> <td class=fndef-content >Kalachev, Gleb, Pavel Panteleev, and Man-Hong Yung. “Multi-Tensor Contraction for XEB Verification of Quantum Circuits.” arXiv, May 18, 2022. <a href="https://doi.org/10.48550/arXiv.2108.05665">https://doi.org/10.48550/arXiv.2108.05665</a>. </table> <table class=fndef  id="fndef:Markov"> <tr> <td class=fndef-backref ><a href="#fnref:Markov">[4]</a> <td class=fndef-content >Markov, Igor L., and Yaoyun Shi. “Simulating Quantum Computation by Contracting Tensor Networks.” SIAM Journal on Computing 38, no. 3 &#40;January 2008&#41;: 963–81. <a href="https://doi.org/10.1137/050644756">https://doi.org/10.1137/050644756</a>. </table> <table class=fndef  id="fndef:Bouchitté"> <tr> <td class=fndef-backref ><a href="#fnref:Bouchitté">[5]</a> <td class=fndef-content >Bouchitté, Vincent, and Ioan Todinca. “Treewidth and Minimum Fill-in: Grouping the Minimal Separators.” SIAM Journal on Computing 31, no. 1 &#40;January 2001&#41;: 212–32. <a href="https://doi.org/10.1137/S0097539799359683">https://doi.org/10.1137/S0097539799359683</a>. </table> <table class=fndef  id="fndef:Berry"> <tr> <td class=fndef-backref ><a href="#fnref:Berry">[6]</a> <td class=fndef-content >Berry, Anne, Jean-Paul Bordat, and Olivier Cogis. “Generating All the Minimal Separators of a Graph.” In Graph-Theoretic Concepts in Computer Science, edited by Peter Widmayer, Gabriele Neyer, and Stephan Eidenbenz, 1665:167–72. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer Berlin Heidelberg, 1999. <a href="https://doi.org/10.1007/3-540-46784-X_17">https://doi.org/10.1007/3-540-46784-X_17</a>. </table> <table class=fndef  id="fndef:BouchittéListing"> <tr> <td class=fndef-backref ><a href="#fnref:BouchittéListing">[7]</a> <td class=fndef-content >Bouchitté, Vincent, and Ioan Todinca. “Listing All Potential Maximal Cliques of a Graph.” Theoretical Computer Science, 2002. <a href="https://doi.org/10.1016/S0304-3975&#40;01&#41;00007-X">https://doi.org/10.1016/S0304-3975&#40;01&#41;00007-X</a>. </table> <table class=fndef  id="fndef:Tuukka"> <tr> <td class=fndef-backref ><a href="#fnref:Tuukka">[8]</a> <td class=fndef-content >Tuukka Korhonen, &quot;Finding Optimal Tree Decompositions&quot;, 2020. <a href="https://tuukkakorhonen.com/papers/msc-thesis.pdf">https://tuukkakorhonen.com/papers/msc-thesis.pdf</a> </table> </p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Xuanzhao Gao. Last modified: August 16, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script> </div> </main>