<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/jemdoc.css"> <link rel=icon  href="/assets/profile.png"> <title>Tensor network contraction order with optimal tree decomposition</title> <main class=outside > <div class=box > <aside class=layout-menu > <div class=menu-category >Xuanzhao Gao's Site</div> <div class="menu-item "><a href="/">Home</a></div> <div class=menu-category >Blogs</div> <div class="menu-item "><a href="/blogs/CuTropicalGEMM/">GEMM on GPU</a></div> <div class="menu-item "><a href="/blogs/contractionorder">TN Contraction Order</a></div> <div class="menu-item "><a href="/blogs/treewidth">Tree Width</a></div> </aside> <div class=layout-content > <div class=franklin-content > <h1 id=tensor_network_contraction_order_optimization_with_optimal_tree_decomposition ><a href="#tensor_network_contraction_order_optimization_with_optimal_tree_decomposition" class=header-anchor >Tensor Network Contraction Order Optimization with Optimal Tree Decomposition</a></h1> <p>This blog is a technical note for the <a href="https://summerofcode.withgoogle.com">Google Summer of Code 2024</a> project <a href="https://summerofcode.withgoogle.com/programs/2024/projects/B8qSy9dO">&quot;Tensor network contraction order optimization and visualization&quot;</a> released by <strong>The Julia Language</strong>, where I developed a package <a href="https://github.com/ArrogantGao/TreeWidthSolver.jl">TreeWidthSolver.jl</a> for calculating the tree decomposition with minimal treewidth of a given simple graph and made it a backend of <a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContracionOrders.jl</a>.</p> <p>This blog covers the following contents:</p> <ol> <li><p>Contraction order of tensor network</p> <li><p>Tree decomposition and its relation to contraction order</p> <li><p>Finding tree decomposition with minimal treewidth</p> </ol> <p>In this blog, we will use the Einsum notation from <a href="https://github.com/under-Peter/OMEinsum.jl">OMEinsum.jl</a>.</p> <h2 id=tensor_network_contraction_order ><a href="#tensor_network_contraction_order" class=header-anchor >Tensor Network Contraction Order</a></h2> <p>In this blog, we will not introduce the basic concept of tensor network, since it has been well introduced in many other places. Instead, we recommend the following references:</p> <ul> <li><p>For readers with physics background: <a href="https://tensornetwork.org/diagrams/">https://tensornetwork.org/diagrams/</a></p> <li><p>For readers want to get a formal definition: Chapter 2 of <a href="https://epubs.siam.org/doi/abs/10.1137/22M1501787">https://epubs.siam.org/doi/abs/10.1137/22M1501787</a></p> </ul> <p>For simplicity, in the following sections, we will use the Einstein summation formula to represent the tensor network as high dimensional arrays&#39; multiplication:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msub><mi>R</mi><mrow><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo separator=true >,</mo><mi>k</mi><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>a</mi><mo separator=true >,</mo><mi>b</mi><mo separator=true >,</mo><mi>c</mi><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow></munder><msub><mi>A</mi><mrow><mi>a</mi><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow></msub><msub><mi>B</mi><mrow><mi>b</mi><mo separator=true >,</mo><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow></msub><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">R_{i,j,k,...} = \sum_{a, b, c, ...} A_{a,...}B_{b,...}...</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.9694em;vertical-align:-0.2861em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:2.4882em;vertical-align:-1.4382em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class=pstrut  style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">c</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span></span></span></span><span style="top:-3.05em;"><span class=pstrut  style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.4382em;"><span></span></span></span></span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal">A</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mord >...</span></span></span></span></span> <p>It is easy to see that the most direct way to calculate the result is to loop over all the indices naively, which requires <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>d</mi><mi>N</mi></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(d^N)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">d</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> operations, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> is the dimension of the index and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is the number of indices. However, such a direct calculation is not efficient. Considering the following simple tensor network:</p> <p><img src="/assets/treewidth_figs/ABCD.png" alt="" /></p> <p>where the tensors are represented by the circles and the indices are represented by the lines, representing the following contraction to scalar <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>s</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo separator=true >,</mo><mi>k</mi><mo separator=true >,</mo><mi>l</mi></mrow></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>B</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>C</mi><mrow><mi>j</mi><mi>l</mi></mrow></msub><msub><mi>D</mi><mrow><mi>l</mi><mi>k</mi></mrow></msub><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex">s = \sum_{i,j,k,l} A_{ij} B_{ik} C_{jl} D_{lk},</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:2.4882em;vertical-align:-1.4382em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class=pstrut  style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.05em;"><span class=pstrut  style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.4382em;"><span></span></span></span></span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal">A</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span></span></span></span></span> <p>and can be represented as the following Einstein summation formula:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> OMEinsum

julia&gt; einsum = <span class=hljs-string >ein&quot;ij, ik, jl, lk -&gt; &quot;</span>
ij, ik, jl, lk -&gt;</code></pre> <p>where pointing to nothing means the result is a scalar. Here we simply assume that all indices are of the same dimension <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>. Then the naive way to calculate the result is to loop over all the indices, which requires <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>4</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^4)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> operations and no intermediate tensors are produced.</p> <p>However, another way to calculate <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> is shown below:</p> <p><img src="/assets/treewidth_figs/ABCD_contraction.png" alt="" /></p> <p>where we first contract <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> to get <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, and contract <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> to get <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">CD</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>, which are rank-2 intermediate tensors, and then contract <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> with <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">CD</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> to get the scalar <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>. That is equivalent to the following Einstein summation formula:</p> <pre><code class="julia hljs">julia&gt; nested_ein = <span class=hljs-string >ein&quot;(ij, ik), (jl, lk) -&gt; &quot;</span>
jk, jk -&gt;
├─ ij, ik -&gt; jk
│  ├─ ij
│  └─ ik
└─ jl, lk -&gt; jk
   ├─ jl
   └─ lk</code></pre> <p>In this way, the total number of operations is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mn>2</mn><msup><mi>D</mi><mn>3</mn></msup><mo>+</mo><msup><mi>D</mi><mn>2</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(2 D^{3} + D^{2})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord >2</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, which is smaller than the naive calculation, while the trade-off is that we need to store the intermediate tensors <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">CD</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> with size of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>2</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^{2})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, as shown below:</p> <pre><code class="julia hljs"><span class=hljs-comment ># here we take D = 16</span>
julia&gt; size_dict = uniformsize(einsum, <span class=hljs-number >2</span>^<span class=hljs-number >4</span>)

julia&gt; contraction_complexity(einsum, size_dict)
Time complexity: <span class=hljs-number >2</span>^<span class=hljs-number >16.0</span>
Space complexity: <span class=hljs-number >2</span>^<span class=hljs-number >0.0</span>
Read-write complexity: <span class=hljs-number >2</span>^<span class=hljs-number >10.001408194392809</span>

julia&gt; contraction_complexity(nested_ein, size_dict)
Time complexity: <span class=hljs-number >2</span>^<span class=hljs-number >13.044394119358454</span>
Space complexity: <span class=hljs-number >2</span>^<span class=hljs-number >8.0</span>
Read-write complexity: <span class=hljs-number >2</span>^<span class=hljs-number >11.000704269011246</span></code></pre> <p>We say such a contraction is with <strong>time complexity</strong> of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>3</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^{3})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> and <strong>space complexity</strong> of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>D</mi><mn>4</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(D^{4})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, which are defined as follows:</p> <ul> <li><p><strong>time complexity</strong>: the number of Floating Point operations required to calculate the result;</p> <li><p><strong>space complexity</strong>: the largest size of the intermediate tensors.</p> </ul> <p>For larger tensor networks, the contraction order is important, since it can greatly reduce the time complexity of the calculation.</p> <p>In actual calculation, we prefer binary contractions, i.e., contracting two tensors at a time, by converting these two tensors as matrices, so that we can make use of BLAS libraries to speed up the calculation. In this way, a given contraction order can be represented as a binary tree. The contraction tree can be represented as a rooted tree, where the leaves are the tensors to be contracted and the internal nodes are the intermediate tensors. The contraction tree corresponding to the above example is shown below:</p> <p><img src="/assets/treewidth_figs/ABCD_tree.png" alt="" /></p> <p>Generally speaking, our target is to find a binary contraction order, with minimal time complexity or space complexity, which is called the <strong>optimal contraction order</strong>.</p> <h3 id=tools_for_tensor_network_contraction_order_optimization ><a href="#tools_for_tensor_network_contraction_order_optimization" class=header-anchor >Tools for Tensor Network Contraction Order Optimization</a></h3> <p>In practice, there are many tools for tensor network contraction order optimization, including:</p> <ul> <li><p><a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContractionOrder.jl</a>: an open-source Julia package for finding the optimal contraction order of tensor networks, is used as backend of <a href="https://github.com/under-Peter/OMEinsum.jl">OMEinsum.jl</a> and <a href="https://github.com/mtfishman/ITensorNetworks.jl">ITensorNetworks.jl</a>.</p> <li><p><a href="https://cotengra.readthedocs.io/en/latest/">Cotengra</a><sup id="fnref:Gray"><a href="#fndef:Gray" class=fnref >[1]</a></sup> : a python library for contracting tensor networks or einsum expressions involving large numbers of tensors.</p> </ul> <p>Various methods have been proposed for optimizing the contraction order, as shown in the table below, here we introduce some of them.</p> <table><tr><th align=right >Optimizer<th align=right >Description<th align=right >Available in<tr><td align=right >Exhaustive Search<td align=right >Slow, exact<td align=right >TensorOperations.jl<tr><td align=right >Greedy Algorithm<td align=right >Fast, heuristic<td align=right >OMEinsumContractionOrders.jl, Cotengra<tr><td align=right >Binary Partition<td align=right >Fast, heuristic<td align=right >OMEinsumContractionOrders.jl, Cotengra<tr><td align=right >Local Search<td align=right >Fast, heuristic<td align=right >OMEinsumContractionOrders.jl<tr><td align=right >Exact Treewidth<td align=right >Slow, exact<td align=right >OMEinsumContractionOrders.jl</table> <h4 id=exhaustive_search ><a href="#exhaustive_search" class=header-anchor >Exhaustive Search</a></h4> <p>The exhaustive search <sup id="fnref:Robert"><a href="#fndef:Robert" class=fnref >[2]</a></sup> is a method to get the exact optimal contraction complexity. There are three different ways to implement the exhaustive search:</p> <ul> <li><p><strong>Depth-first constructive approach</strong>: in each step, choose a pair of tensors to contract a new tensor until all tensors are contracted, and then iterate over all possible contraction sequences without duplication. Note the cheapest contraction sequence thus found.</p> <li><p><strong>Breadth-first constructive approach</strong>: the breadth-first method construct the set of intermediate tensors by contracting <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> tensors &#40;<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mo stretchy=false >[</mo><mn>1</mn><mo separator=true >,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">c \in [1, n - 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >1</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is the number of tensors&#41; in each step, and record the optimal cost for constructing each intermediate tensor. Then in the last step, the optimal cost for contracting all <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> tensors is obtained.</p> <li><p><strong>Dynamic programming</strong>: in each step, consider all bipartition that split the tensor network into two parts, if the optimal cost for each part is not recorded, further split them until the cost has been already obtained or only one tensor is left. Then combine the two parts and record the optimal cost of contracting the sub-networks. In this end the optimal cost for the whole network is obtained.</p> </ul> <p>In more recent work <sup id="fnref:Robert"><a href="#fndef:Robert" class=fnref >[2]</a></sup>, by reordering the search process in favor of cheapest-first and excluding large numbers of outer product contractions which are shown to be unnecessary, the efficiency of the exhaustive search has been greatly improved. The method has been implemented in <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a>.</p> <h4 id=greedy_algorithm ><a href="#greedy_algorithm" class=header-anchor >Greedy Algorithm</a></h4> <p>The Greedy method is one of the simplest and fastest method for optimizing the contraction order. The idea is to greedily select the pair of tensors with the smallest cost to contract at each step. In each step, for all possible pairs of tensors, the cost of the contraction is evaluated, and the pair with the smallest cost is selected and then contracted, which forms a new tensor. This process is repeated until all tensors are contracted. This method is fast, however it is easy to be trapped in local minima.</p> <p>An enhanced method is called the hyper-greedy method, where in each step one does not directly select the pair with the smallest cost, but instead samples according to the Boltzmann distribution given by <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >P</mi><mo stretchy=false >(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator=true >,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=false >)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mrow><mi>L</mi><mo stretchy=false >(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator=true >,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=false >)</mo></mrow><mi mathvariant=normal >/</mi><mi>T</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathcal{P}(v_i, v_j) = e^{-{L(v_i, v_j)} / {T}}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.888em;"></span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator=true >,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(v_i, v_j)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2861em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> is the cost function. In this case, it is possible for the process to escape from local minima. Then we run this process multiple times and select the best result. The method has already been used in both OMEinsumContractionOrders.jl and Cotengra. </p> <h4 id=binary_partition ><a href="#binary_partition" class=header-anchor >Binary Partition</a></h4> <p>A given tensor network can be regarded as a hypergraph, where the tensors are the vertices and the shared indices are the hyperedges, and the cost of contracting a hyper edge can be encoded as its weight. The binary partition method is to partition the hypergraph into two parts, and then recursively partition each part. Cost of each partition can be evaluated by the sum of the weights of the hyperedges cut by the partition, while we prefer to make the partition as balanced as possible &#40;balance means size of the subgraph should be similar&#41;. Thus, the problem is reduced to a balanced min cut problem on a hypergraph. In the past few decades, the graph community has developed many algorithms for the balanced min cut problem and provided the corresponding software packages, such as <a href="https://kahypar.org">KaHyPar</a> <sup id="fnref:kahypar"><a href="#fndef:kahypar" class=fnref >[3]</a></sup>, which has already been used in both OMEinsumContractionOrders.jl and Cotengra. </p> <h4 id=local_search_method ><a href="#local_search_method" class=header-anchor >Local Search Method</a></h4> <p>The local search method <sup id="fnref:Kalachev"><a href="#fndef:Kalachev" class=fnref >[4]</a></sup> &#40;also called the tree simulated annealing&#41; is another type of the optimization method based on local search and simulating annealing. TreeSA is based on the following rules:</p> <ul> <li><p>Associativity: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>×</mo><mo stretchy=false >(</mo><mi>S</mi><mo>×</mo><mi>R</mi><mo stretchy=false >)</mo><mo>=</mo><mo stretchy=false >(</mo><mi>T</mi><mo>×</mo><mi>S</mi><mo stretchy=false >)</mo><mo>×</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">T \times (S \times R) = (T \times S) \times R</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</p> <li><p>Commutativity: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>×</mo><mi>S</mi><mo>=</mo><mi>S</mi><mo>×</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T \times S = S \times T</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</p> </ul> <p>These rules lead to the four possible transforms of the contraction tree as shown in the following figure.</p> <p><img src="/assets/treewidth_figs/treesa.png" alt="" /></p> <p>The TreeSA method starts from a random contraction tree and then applies the above rules to transform the tree. The cost of the contraction tree is evaluated and the tree is updated according to the Metropolis criterion. During the process, the temperature is gradually decreased, and the process stop when the temperature is low enough. The method has already been used in OMEinsumContractionOrders.jl.</p> <p>The method listed above are powerful and efficient, which can be used to find great contraction orders of various tensor networks. However, the methods above except exhaustive search are heuristic methods and may not guarantee to find the optimal contraction order, while the exhaustive search can be too slow for large tensor networks. In the following sections, we will introduce a method to find the optimal contraction order based on the optimal tree decomposition.</p> <h2 id=finding_the_optimal_contraction_order_via_tree_decomposition ><a href="#finding_the_optimal_contraction_order_via_tree_decomposition" class=header-anchor >Finding the Optimal Contraction Order via Tree Decomposition</a></h2> <p>In the previous section, we introduce the concept of tensor network and its contraction order, so that now you should understand why the contraction order so important. Then the next question is how to find the optimal contraction order.</p> <p>In our work, we propose to use the tree decomposition of the line graph of the hypergraph representation of the tensor network to find the optimal contraction order, according to the following well known theorem<sup id="fnref:Markov"><a href="#fndef:Markov" class=fnref >[5]</a></sup> :</p> <p><strong>Theorem 1</strong>. Let <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> be a quantum circuit with <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> gates and whose underlying circuit graph is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">G_c</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Then <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> can be simulated deterministically in time <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mrow><mi>O</mi><mo stretchy=false >(</mo><mn>1</mn><mo stretchy=false >)</mo></mrow></msup><msup><mi>e</mi><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><msub><mi>G</mi><mi>C</mi></msub><mo stretchy=false >)</mo><mo stretchy=false >)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">T^{O(1)} e^{O(tw(G_C))}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.888em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">tw</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3448em;"><span style="top:-2.3567em;margin-left:0em;margin-right:0.0714em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.1433em;"><span></span></span></span></span></span></span><span class="mclose mtight">))</span></span></span></span></span></span></span></span></span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><msub><mi>G</mi><mi>C</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">tw(G_C)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">tw</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> is the treewidth of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">G_C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">G</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p> <p>Using the language of tensor network, we can rewrite the above theorem as follows: the bottleneck of time complexity of the contraction of a tensor network is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>e</mi><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo><mo stretchy=false >)</mo><mo stretchy=false >)</mo></mrow></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(e^{O(tw(L(G)))})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">tw</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">L</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">G</span><span class="mclose mtight">)))</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> is the line graph of the hypergraph representation of the tensor network. Therefore, if we can find the tree decomposition of the tensor network with minimal treewidth, we can find the optimal contraction order of the tensor network. We developed a package <a href="https://github.com/ArrogantGao/TreeWidthSolver.jl">TreeWidthSolver.jl</a> for finding the optimal tree decomposition of a given simple graph, which can be used as a backend of <a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContractionOrders.jl</a>. For more details about the tree decomposition and its relation to the contraction order, please refer to the appendix.</p> <p>Here is an example of usage:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> OMEinsum, OMEinsumContractionOrders

<span class=hljs-comment ># define the contraction using Einstein summation</span>
julia&gt; code = <span class=hljs-string >ein&quot;ijl, ikm, jkn, l, m, n -&gt; &quot;</span>
ijl, ikm, jkn, l, m, n -&gt; 

ulia&gt; optimizer = ExactTreewidth()
ExactTreewidth{GreedyMethod{<span class=hljs-built_in >Float64</span>, <span class=hljs-built_in >Float64</span>}}(GreedyMethod{<span class=hljs-built_in >Float64</span>, <span class=hljs-built_in >Float64</span>}(<span class=hljs-number >0.0</span>, <span class=hljs-number >0.0</span>, <span class=hljs-number >1</span>))

<span class=hljs-comment ># set the size of the indices</span>
julia&gt; size_dict = uniformsize(code, <span class=hljs-number >2</span>)
<span class=hljs-built_in >Dict</span>{<span class=hljs-built_in >Char</span>, <span class=hljs-built_in >Int64</span>} with <span class=hljs-number >6</span> entries:
  <span class=hljs-string >&#x27;n&#x27;</span> =&gt; <span class=hljs-number >2</span>
  <span class=hljs-string >&#x27;j&#x27;</span> =&gt; <span class=hljs-number >2</span>
  <span class=hljs-string >&#x27;i&#x27;</span> =&gt; <span class=hljs-number >2</span>
  <span class=hljs-string >&#x27;l&#x27;</span> =&gt; <span class=hljs-number >2</span>
  <span class=hljs-string >&#x27;k&#x27;</span> =&gt; <span class=hljs-number >2</span>
  <span class=hljs-string >&#x27;m&#x27;</span> =&gt; <span class=hljs-number >2</span>

julia&gt; optcode = optimize_code(code, size_dict, optimizer)
n, n -&gt; 
├─ jk, jkn -&gt; n
│  ├─ ij, ik -&gt; jk
│  │  ├─ ijl, l -&gt; ij
│  │  │  ├─ ijl
│  │  │  └─ l
│  │  └─ ikm, m -&gt; ik
│  │     ├─ ikm
│  │     └─ m
│  └─ jkn
└─ n

<span class=hljs-comment ># check the complexity</span>
julia&gt; contraction_complexity(optcode, size_dict)
Time complexity: <span class=hljs-number >2</span>^<span class=hljs-number >5.087462841250339</span>
Space complexity: <span class=hljs-number >2</span>^<span class=hljs-number >2.0</span>
Read-write complexity: <span class=hljs-number >2</span>^<span class=hljs-number >5.882643049361841</span>

<span class=hljs-comment ># check the results</span>
julia&gt; A = rand(<span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>); B = rand(<span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>); C = rand(<span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>); D = rand(<span class=hljs-number >2</span>); E = rand(<span class=hljs-number >2</span>); F = rand(<span class=hljs-number >2</span>);

julia&gt; code(A, B, C, D, E, F) ≈ optcode(A, B, C, D, E, F)
<span class=hljs-literal >true</span></code></pre> <p>This optimizer will be used as an extension of <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a> in the future, see this <a href="https://github.com/Jutho/TensorOperations.jl/pull/185">PR</a>. We compared the performance of this method against the default optimizer of TensorOperations.jl based on exhaustive searching, the results is shown below.</p> <p><img src="https://github.com/ArrogantGao/TreeWidthSolver_benchmark/blob/main/figs/compare_TO.png?raw&#61;true" alt="" /></p> <p>The results shown that the tree width based solver is faster for some graph similar to trees. For more details, please see the benchmark repo: <a href="https://github.com/ArrogantGao/TreeWidthSolver_benchmark">https://github.com/ArrogantGao/TreeWidthSolver_benchmark</a>.</p> <h2 id=appendix_details_about_tree_decomposition_and_its_relation_to_contraction_order ><a href="#appendix_details_about_tree_decomposition_and_its_relation_to_contraction_order" class=header-anchor >Appendix: Details about Tree Decomposition and its Relation to Contraction Order</a></h2> <h3 id=line_graph ><a href="#line_graph" class=header-anchor >Line Graph</a></h3> <p>A formal definition of the <a href="https://en.wikipedia.org/wiki/Line_graph"><strong>line graph</strong></a> is as follows:</p> <p><strong>Definition 1</strong>. Given a graph G, its line graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> is a graph such that: </p> <ol> <li><p>each vertex of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> represents an edge of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>; </p> <li><p>two vertices of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> are adjacent if and only if their corresponding edges share a common endpoint &#40;&quot;are incident&quot;&#41; in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>. </p> </ol> <p>That is, it is the intersection graph of the edges of G, representing each edge by the set of its two endpoints.</p> <p>For a tensor network, we can construct a hypergraph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> whose vertices are the tensors and whose hyperedges are the indices. Then the line graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span> of the hypergraph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is the graph whose vertices are the indices and whose edges are the tensors, which is a simple graph, as shown in the following figure:</p> <p><img src="/assets/treewidth_figs/linegraph.png" alt=Fig.1  /></p> <p>Since we are considering a tensor network, dimension of the indices have to be considered. Therefore, for each vertex of the line graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>, we define its weight as <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy=false >(</mo><mi>d</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\log_2(d)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop ><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2441em;"><span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">d</span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> is the dimension of the index. In this way, size of a tensor can be represented as the sum of weights of the vertices in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class=mopen >(</span><span class="mord mathnormal">G</span><span class=mclose >)</span></span></span></span>.</p> <h3 id=tree_decomposition_and_tree_width ><a href="#tree_decomposition_and_tree_width" class=header-anchor >Tree Decomposition and Tree Width</a></h3> <p>Intuitively, a <a href="https://en.wikipedia.org/wiki/Tree_decomposition"><strong>tree decomposition</strong></a> represents the vertices of a given graph <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> as subtrees of a tree, in such a way that vertices in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> are adjacent only when the corresponding subtrees intersect.</p> <p>The tree decomposition of a graph is a tree whose nodes are subsets of the vertices of the graph, and the following conditions are satisfied:</p> <ol> <li><p>Each vertex of the graph is in at least one node of the tree.</p> <li><p>For each edge of the graph, there is a node of the tree containing both vertices of the edge.</p> <li><p>Bags containing the same vertex have to be connected in the tree.</p> </ol> <p>All the nodes of the tree are called <strong>tree bags</strong>, and intersection of two bags is called a <strong>separator</strong>. The width of a tree decomposition is the size of the largest bag minus one. Clearly, one graph can have multiple tree decomposition with different corresponding widths. The tree width of a graph is the minimal width of all such decompositions, and a particular decomposition &#40;not necessarily unique&#41; that realises this minimal width is called an optimal tree decomposition.</p> <p>An example of the optimal tree decomposition is shown in the following figure:</p> <p><img src="/assets/treewidth_figs/treedecomposition_2.png" alt="" /></p> <p>where the left graph is the original graph and the right one is the tree decomposition of the graph, and the tree width is 2.</p> <p>To find the optimal tree decomposition of a simple graph, one can use the Bouchitté-Todinca algorithm <sup id="fnref:Bouchitté"><a href="#fndef:Bouchitté" class=fnref >[6]</a></sup>, which is discussed in detail in the blog <a href="/blogs/treewidth/">Finding the Optimal Tree Decomposition with Minimal Treewidth</a>, one can refer to it for more details.</p> <h3 id=from_tree_decomposition_to_contraction_order ><a href="#from_tree_decomposition_to_contraction_order" class=header-anchor >From Tree Decomposition to Contraction Order</a></h3> <p>Then how tree decomposition and tree width are related to the contraction order of the tensor network? In this sub-section, we will answer the following questions: how to get a contraction order from a tree decomposition? And why the contraction order is optimal if the tree width is minimal?</p> <p>For the first question, according to the definition of tree decomposition, we can obtain vertices elimination order by traversing the tree decomposition in a bottom-up manner. For each node of the tree decomposition, a vertex can be eliminated if it is in the bag of the node and not in the bags of its parent node, as shown in the figure below:</p> <p><img src="/assets/treewidth_figs/elimination_order2.png" alt="" /></p> <p>and the order is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >{</mo><mo stretchy=false >{</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo separator=true >,</mo><mi>l</mi><mo stretchy=false >}</mo><mo separator=true >,</mo><mo stretchy=false >{</mo><mi>k</mi><mo stretchy=false >}</mo><mo separator=true >,</mo><mo stretchy=false >{</mo><mi>m</mi><mo stretchy=false >}</mo><mo separator=true >,</mo><mo stretchy=false >{</mo><mi>n</mi><mo stretchy=false >}</mo><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\{\{i, j, l\}, \{k\}, \{m\}, \{n\}\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{{</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class=mclose >}</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mclose >}</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mopen >{</span><span class="mord mathnormal">m</span><span class=mclose >}</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mopen >{</span><span class="mord mathnormal">n</span><span class=mclose >}}</span></span></span></span>, where the last vertex is to be eliminated first.</p> <p>The elimination order of the indices can then be used to determine the contraction order of the tensor network, where two tensors are contracted if they share a common index and the index is eliminated. According to the elimination order above, the contraction is shown below:</p> <p><img src="/assets/treewidth_figs/elimination.png" alt="" /></p> <p>Of course, the contraction order is not unique as, by selecting different node as the root of the decomposition tree, different contraction orders can be obtained.</p> <p>Then to answer the second question, we have to introduce a property of the optimal tree decomposition:</p> <p><strong>Proposition 1</strong>: all tree bags of the optimal tree decomposition are cliquish, i.e., the vertices in the same bag are either connected or belong to the same separator.</p> <p>If two indices are connected in the line graph, then they at least belong to a same tensor. For the separators, notice that in a contraction order from a tree decomposition, a separator is exactly the indices of an intermediate tensor, so that they should also be treated as connected. In the example above, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">BE</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">BE</span></span></span></span> has indices <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">ik</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">ik</span></span></span></span>, corresponding to the separator <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >{</mo><mi>i</mi><mo separator=true >,</mo><mi>k</mi><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\{i, k\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mclose >}</span></span></span></span> between tree bags <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >{</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo separator=true >,</mo><mi>k</mi><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\{i, j, k\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mclose >}</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >{</mo><mi>i</mi><mo separator=true >,</mo><mi>k</mi><mo separator=true >,</mo><mi>m</mi><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\{i, k, m\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class=mclose >}</span></span></span></span>, and so on.</p> <p>Therefore, in a tree bag all indices are &quot;connected&quot;, in each step of the contraction, we will have to loop over all the indices in the same bag, so that the bottleneck of time complexity is exactly by <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>e</mi><mrow><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(e^{tw(G) + 1})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">tw</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">G</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, and the since all intermediate tensors are characterized by the separators, and separators are real subset of tree bags, the space complexity bounded by <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>e</mi><mrow><mi>t</mi><mi>w</mi><mo stretchy=false >(</mo><mi>G</mi><mo stretchy=false >)</mo></mrow></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(e^{tw(G)})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">e</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">tw</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">G</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>.</p> <p><strong>Remark</strong>: It should be remarked in the general cases, sizes of the separators &#40;the intersection of the bags&#41; may not be size of the bags minus one.</p> <p>Thus, we can conclude that the contraction order obtained from the optimal tree decomposition is the optimal contraction order of the tensor network.</p> <h2 id=reference ><a href="#reference" class=header-anchor >Reference</a></h2> <p><table class=fndef  id="fndef:Gray"> <tr> <td class=fndef-backref ><a href="#fnref:Gray">[1]</a> <td class=fndef-content >Gray, Johnnie, and Stefanos Kourtis. “Hyper-Optimized Tensor Network Contraction.” Quantum 5 &#40;March 15, 2021&#41;: 410. <a href="https://doi.org/10.22331/q-2021-03-15-410">https://doi.org/10.22331/q-2021-03-15-410</a>. </table> <table class=fndef  id="fndef:Robert"> <tr> <td class=fndef-backref ><a href="#fnref:Robert">[2]</a> <td class=fndef-content >Robert N. C. Pfeifer, Jutho Haegeman, and Frank Verstraete. &quot;Faster identification of optimal contraction sequences for tensor networks&quot; Phys. Rev. E <a href="https://doi.org/10.1103/PhysRevE.90.033315">https://doi.org/10.1103/PhysRevE.90.033315</a> </table> <table class=fndef  id="fndef:kahypar"> <tr> <td class=fndef-backref ><a href="#fnref:kahypar">[3]</a> <td class=fndef-content >Schlag, Sebastian, Tobias Heuer, Lars Gottesbüren, Yaroslav Akhremtsev, Christian Schulz, and Peter Sanders. “High-Quality Hypergraph Partitioning.” ACM Journal of Experimental Algorithmics 27 &#40;December 31, 2022&#41;: 1–39. <a href="https://doi.org/10.1145/3529090">https://doi.org/10.1145/3529090</a>. </table> <table class=fndef  id="fndef:Kalachev"> <tr> <td class=fndef-backref ><a href="#fnref:Kalachev">[4]</a> <td class=fndef-content >Kalachev, Gleb, Pavel Panteleev, and Man-Hong Yung. “Multi-Tensor Contraction for XEB Verification of Quantum Circuits.” arXiv, May 18, 2022. <a href="https://doi.org/10.48550/arXiv.2108.05665">https://doi.org/10.48550/arXiv.2108.05665</a>. </table> <table class=fndef  id="fndef:Markov"> <tr> <td class=fndef-backref ><a href="#fnref:Markov">[5]</a> <td class=fndef-content >Markov, Igor L., and Yaoyun Shi. “Simulating Quantum Computation by Contracting Tensor Networks.” SIAM Journal on Computing 38, no. 3 &#40;January 2008&#41;: 963–81. <a href="https://doi.org/10.1137/050644756">https://doi.org/10.1137/050644756</a>. </table> <table class=fndef  id="fndef:Bouchitté"> <tr> <td class=fndef-backref ><a href="#fnref:Bouchitté">[6]</a> <td class=fndef-content >Bouchitté, Vincent, and Ioan Todinca. “Treewidth and Minimum Fill-in: Grouping the Minimal Separators.” SIAM Journal on Computing 31, no. 1 &#40;January 2001&#41;: 212–32. <a href="https://doi.org/10.1137/S0097539799359683">https://doi.org/10.1137/S0097539799359683</a>. </table> </p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Xuanzhao Gao. Last modified: December 18, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script> </div> </main>